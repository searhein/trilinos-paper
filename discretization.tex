\todo{work on this after the new pruducts structure is defined}
The discretization product contains several packages to handle discretizations of differential equations.

\subsection{Intrepid2}
Intrepid2 provides interoperable tools for compatible discretizations of PDEs and it is a performance-portable re-implementation of the legacy Intrepid package \cite{bochev2012}. Intrepid2 mainly focuses on local assembly of continuous and discontinuous finite elements. It also provides limited capabilities for finite volume discretization.  Intrepid2 works on batches of elements (cells), and provides tools to efficiently compute discretized linear functionals (e.g., right-hand-side vectors) and differential operators (e.g., stiffness matrices) at the element level. Intrepid2 implements compatible finite element spaces of different order for H(grad), H(curl), H(div) and L2 function spaces on triangles, quadrilaterals, tetrahedrons, hexahedrons, wedges and pyramids. It provides both Lagrangian basis functions and Hierarchical basis functions \cite{fuentes2015} and it implements performance optimizations (e.g., sum factorizations) explointing underline structure of the problem (e.g. tensor-product elements or other symmetries).  The degrees of freedom of H(div) and H(curl) finite elements, as well as high-order H(grad) finite elements, depend on the global orientation of edges and faces and Intrepid2 provides orientation tools for matching the degrees of freedom on shared edges and faces. It also provides interpolation-based projection tools for projecting functions in H(grad), H(curl), H(div) and L2 to the respective discrete spaces.  
\begin{itemize}
\item[CellTools] This class provides geometric operations on the reference and physical frame. Includes computation of tangents and normals to edges/faces in the physical frame, computation of Jacobian of the reference-to-physical frame maps, and other metric informations. 
\item[CubatureFactory] This class provides several quadrature rules (called Cubatures in Intrepid2) of different degrees of exactness for approximating integrals over the elements and their boundaries
\item[Basis] this is the base class for a variety of basis functions for compatible finite element spaces. Each class has a method getValues that returns the value of the basis functions or their derivatives (e.g., gradient for H(grad) functions, curl for H(curl) functions) at a set of input  points. The implmentation of getValues can be very different depending on the basis. Specific optimizations are available for tensor-product elements.
\item[OrientationTools] This class provides methods to orient the basis functions based on the global orientation of edges and faces, determined by the global numbering of the cell vertices. This is achieved by building a linear operator (a permutation for tensor-product elements) that encodes the orientation of a particular cell, and applying such operator the reference basis functions.
\item[ProjectionTools] This class provides methods for interpolation-based projections of given function into a compatible finite element space or between compatible finite element spaces \cite{demkowicz2007}.  The provided projections commute with the corresponding differential operators if the quadrature rules can exaclty integrate the functions to project. As an example, projecting an H(grad) function to the H(grad) finite-element space and then taking its gradient gives the same result as taking the gradient of the function first, and then projecting the gradient to the H(curl) finite-element space.
\item[FunctionSpaceTools] This class provides transformations of fields from reference to physical frame and back, computation of measures on edges, faces and cells, scalar/vector/tensor multiplications and contractions for computing integrals \textcolor{red}{Nate, maybe here you can add the functor operations you implemented.}
\end{itemize}
Intrepid2 makes use of Kokkos containers to enable memory layouts that are adapted to the computational platform. Intrepid2 also uses Kokkos for its core computational kernels, enabling threaded execution across a variety of architectures. The data types used by Intrepid2 are templated, it is therefore possible to propagate Sacado types through Intrepid2 to perform automatic differentiation. Current deveopment of Intrepid2 focuses on providing efficient matrix-free discretizations to enhance efficiency on GPU architectures. 

\subsection{Phalanx}
\todo{Roger, please edit/expand}
The package is a local field evaluation kernel specifically designed for general partial differential equation solvers. The main goal of Phalanx is to decompose a complex problem into a number of simpler problems with managed dependencies to support rapid development and extensibility of the PDE code. Through the use of template metaprogramming concepts, Phalanx supports arbitrary user defined data types and evaluation types. This allows for unprecedented flexibility for direct integration with user applications and provides extensive support for embedded technology such as automatic differentiation for sensitivity analysis and uncertainty quantification.

\subsection{Panzer}
\todo{Roger, please edit/expand}
The package provides global tools for finite element analysis. It handles continuous and discontinuous high-order compatible finite elements, as implemented in Intrepid2 on unstructured meshes. Panzer relies on Phalanx to manage with efficiency and flexibility the assembly of complex problems. Panzer also enables the solution of nonlinear problems, by interfacing with several Trlinos linear and nonlinear solvers. It computes derivatives and sensitivities through automatic differentiation (Sacado). It supports both Epetra and Tpetra data structures and achieves performance portability through the Kokkos programming model.

\subsection{Compadre}
\todo{Paul, please edit/expand}
Compadre toolkit provides tools for the approximation of linear operators applied to a function (including point evaluation and derivatives), given samples of the function over a cloud of points. The toolkit can be used for data transfer applications as well as for meshless discretization of PDEs. The package uses generalized moving least squares for approximating functionals and we plan on implementing other meshless methods like radial basis functions. It achieves performance portability by using Kokkos programming model.


