\todo{work on this after the new products structure is defined}
The discretization product contains several packages to handle discretizations of differential equations.

\subsection{Intrepid2}
Intrepid2 provides interoperable tools for compatible discretizations of PDEs; it is a performance-portable re-implementation and extension of the legacy Intrepid package \cite{bochev2012}. Intrepid2 mainly focuses on local assembly of continuous and discontinuous finite elements. It also provides limited capabilities for finite volume discretization.  Intrepid2 works on batches of elements (cells), and provides tools to efficiently compute discretized linear functionals (e.g., right-hand-side vectors) and differential operators (e.g., stiffness matrices) at the element level. Intrepid2 implements compatible finite element spaces of various polynomial orders for $H({\rm grad})$, $H({\rm curl})$, $H({\rm div})$ and $L^2$ function spaces on triangles, quadrilaterals, tetrahedrons, hexahedrons, wedges and pyramids. It provides both Lagrangian basis functions and hierarchical basis functions \cite{fuentes2015} and it implements performance optimizations (e.g., sum factorizations) exploiting the underlying structure of the problem (e.g., tensor-product elements or other symmetries).  The degrees of freedom of $H({\rm div})$ and $H({\rm curl})$ finite elements, as well as high-order $H({\rm grad})$ finite elements, depend on the global orientation of edges and faces and Intrepid2 provides orientation tools for matching the degrees of freedom on shared edges and faces. It also provides interpolation-based projection tools for projecting functions in $H({\rm grad})$, $H({\rm curl})$, $H({\rm div})$ and $L^2$ to the respective discrete spaces.  
\begin{itemize}
\item[CellTools] This class provides geometric operations on the reference and physical frame. Includes computation of tangents and normals to edges/faces in the physical frame, computation of Jacobian of the reference-to-physical frame maps, and other metric computations. 
\item[CubatureFactory] This class provides several quadrature rules (called \emph{cubatures} in Intrepid2) of various degrees of accuracy for approximating integrals over the elements and their boundaries.
\item[Basis] This is the base class for a variety of basis functions for compatible finite element spaces. Each class includes a \texttt{getValues()} method that computes the value of the basis functions or their derivatives (e.g., gradient for $H({\rm grad})$ functions, curl for $H({\rm curl})$ functions) at a set of input points. The implementation of \texttt{getValues()} can be very different depending on the basis. Specific optimizations are available for tensor-product elements.  Additionally, there is a \texttt{BasisFamily} class with a convenience method, \texttt{getBasis()}, which constructs a basis depending on a template argument specifying the type of basis (hierarchical or nodal, e.g.), the cell topology and function space on which it is defined, and its polynomial degree.
\item[OrientationTools] This class provides methods to orient the basis functions based on the global orientation of edges and faces, determined by the global numbering of the cell vertices. This is achieved by building a linear operator (a permutation for tensor-product elements) that encodes the orientation of a particular cell, and applying that operator to the reference basis functions.
\item[ProjectionTools] This class provides methods for interpolation-based projections of a given function into a compatible finite element space or between compatible finite element spaces \cite{demkowicz2007}.  The provided projections commute with the corresponding differential operators if the quadrature rules can exactly integrate the functions being projected. As an example, projecting an $H({\rm grad})$ function into the $H({\rm grad})$ finite-element space and then taking its gradient gives the same result as taking the gradient of the function first, and then projecting the gradient into the $H({\rm curl})$ finite-element space.
\item[FunctionSpaceTools] This class provides transformations of fields from reference to physical frame and back, computation of measures on edges, faces and cells, scalar/vector/tensor multiplications and contractions for computing integrals.
\item[IntegrationTools] This class provides integration methods that can take advantage of tensor product structures in basis values, providing mechanisms for performance-portable, \emph{sum-factorized} assembly across $H({\rm grad})$, $H({\rm curl})$, $H({\rm div})$ and $L^2$ function spaces.  In the future, we plan to provide similar interfaces to support matrix-free discretizations.
\end{itemize}
Intrepid2 makes use of Kokkos containers to enable memory layouts that are adapted to the computational platform. Intrepid2 also uses Kokkos for its core computational kernels, enabling threaded execution across a variety of architectures. The data types used by Intrepid2 are templated; it is therefore possible to propagate Sacado types through Intrepid2 to perform automatic differentiation. Current development of Intrepid2 focuses on providing efficient matrix-free discretizations to enhance efficiency on GPU architectures. 

\subsection{Phalanx}
\todo{Roger, please edit/expand}
The package is a local field evaluation kernel specifically designed for general partial differential equation solvers. The main goal of Phalanx is to decompose a complex problem into a number of simpler problems with managed dependencies to support rapid development and extensibility of the PDE code. Through the use of template metaprogramming concepts, Phalanx supports arbitrary user defined data types and evaluation types. This allows for unprecedented flexibility for direct integration with user applications and provides extensive support for embedded technology such as automatic differentiation for sensitivity analysis and uncertainty quantification.

\subsection{Panzer}
\todo{Roger, please edit/expand}
The package provides global tools for finite element analysis. It handles continuous and discontinuous high-order compatible finite elements, as implemented in Intrepid2 on unstructured meshes. Panzer relies on Phalanx to manage with efficiency and flexibility the assembly of complex problems. Panzer also enables the solution of nonlinear problems, by interfacing with several Trlinos linear and nonlinear solvers. It computes derivatives and sensitivities through automatic differentiation (Sacado). It supports both Epetra and Tpetra data structures and achieves performance portability through the Kokkos programming model.

\subsection{Compadre}
\todo{Paul, please edit/expand}
Compadre toolkit provides tools for the approximation of linear operators applied to a function (including point evaluation and derivatives), given samples of the function over a cloud of points. The toolkit can be used for data transfer applications as well as for meshless discretization of PDEs. The package uses generalized moving least squares for approximating functionals and we plan on implementing other meshless methods like radial basis functions. It achieves performance portability by using Kokkos programming model.


